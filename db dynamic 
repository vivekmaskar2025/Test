# Dynamic DB Utility for Spring Boot 3

This document contains a production-minded example of a Spring Boot 3 utility that exposes REST endpoints to perform **safe dynamic** database operations (list tables, list columns, INSERT, UPDATE, DELETE, ALTER ADD/DROP column) on tables prefixed with `Trade_`.

> **Security note:** executing DDL/DML dynamically is inherently risky. This implementation tries to be conservative: it *only allows tables that start with `Trade_`*, strictly validates identifiers (table/column names), parameterizes values, and constrains allowed ALTER types. **Do not** use this in production without additional access control, audit, backups, and rate-limiting.

---

## How it's organized (single-file layout shown as multiple classes)

- `application.yml` (sample)
- `com.example.dynamicdb.controller.DynamicDbController`
- `com.example.dynamicdb.service.DynamicDbService`
- `com.example.dynamicdb.repository.DynamicDbRepository`
- `com.example.dynamicdb.dto.*` (request/response DTOs)
- `com.example.dynamicdb.util.SqlSanitizer`
- `com.example.dynamicdb.exception.*` (custom exceptions + global handler)

---

## application.yml (sample)

```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: myuser
    password: mypass
  sql:
    identifier-quote: '"' # set to `"` for Postgres, `` ` `` for MySQL
server:
  port: 8080
logging:
  level:
    root: INFO
    com.example.dynamicdb: DEBUG
```

---

## Main Controller

```java
package com.example.dynamicdb.controller;

import com.example.dynamicdb.dto.*;
import com.example.dynamicdb.service.DynamicDbService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/dynamic")
public class DynamicDbController {

    private final DynamicDbService service;

    public DynamicDbController(DynamicDbService service) {
        this.service = service;
    }

    // 1. List tables with prefix Trade_
    @GetMapping("/tables")
    public ResponseEntity<List<String>> listTables(@RequestParam(defaultValue = "Trade_") String prefix) {
        return ResponseEntity.ok(service.listTables(prefix));
    }

    // 2. Get columns for a table
    @GetMapping("/tables/{table}/columns")
    public ResponseEntity<List<ColumnInfo>> getColumns(@PathVariable("table") String table) {
        return ResponseEntity.ok(service.getColumns(table));
    }

    // 3. Execute dynamic operation (INSERT/UPDATE/DELETE/ALTER)
    @PostMapping("/execute")
    public ResponseEntity<OperationResult> execute(@RequestBody OperationRequest request) {
        OperationResult result = service.execute(request);
        return ResponseEntity.ok(result);
    }
}
```

---

## DTOs

```java
package com.example.dynamicdb.dto;

import java.util.List;
import java.util.Map;

public record ColumnInfo(String name, String type, boolean nullable, Integer size) {}

public enum OperationType { INSERT, UPDATE, DELETE, ALTER_ADD_COLUMN, ALTER_DROP_COLUMN, ALTER_MODIFY_COLUMN }

public class OperationRequest {
    public String table; // required
    public OperationType operation; // required
    public Map<String, Object> values; // column -> value (for insert/update)
    public Map<String, Object> where; // conditions for update/delete

    // For ALTER
    public String alterColumnName;
    public String alterColumnType; // e.g. VARCHAR(100), INT
    public Boolean alterNullable; // optional
}

public class OperationResult {
    public boolean success;
    public String message;
    public int affectedRows;

    public OperationResult(boolean success, String message, int affectedRows) {
        this.success = success;
        this.message = message;
        this.affectedRows = affectedRows;
    }
}
```

---

## Service layer (business rules + validation)

```java
package com.example.dynamicdb.service;

import com.example.dynamicdb.dto.*;
import com.example.dynamicdb.exception.BadRequestException;
import com.example.dynamicdb.repository.DynamicDbRepository;
import com.example.dynamicdb.util.SqlSanitizer;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class DynamicDbService {

    private final DynamicDbRepository repo;
    private final SqlSanitizer sanitizer;

    public DynamicDbService(DynamicDbRepository repo, SqlSanitizer sanitizer) {
        this.repo = repo;
        this.sanitizer = sanitizer;
    }

    public List<String> listTables(String prefix) {
        if (prefix == null || prefix.isBlank()) throw new BadRequestException("prefix required");
        return repo.listTables(prefix);
    }

    public List<ColumnInfo> getColumns(String table) {
        sanitizer.validateAllowedTable(table);
        return repo.getColumns(table);
    }

    @Transactional
    public OperationResult execute(OperationRequest req) {
        sanitizer.validateAllowedTable(req.table);
        if (req.operation == null) throw new BadRequestException("operation required");

        switch (req.operation) {
            case INSERT -> {
                if (req.values == null || req.values.isEmpty()) throw new BadRequestException("values required for insert");
                return repo.insert(req.table, req.values);
            }
            case UPDATE -> {
                if (req.values == null || req.values.isEmpty()) throw new BadRequestException("values required for update");
                if (req.where == null || req.where.isEmpty()) throw new BadRequestException("where conditions required for update");
                return repo.update(req.table, req.values, req.where);
            }
            case DELETE -> {
                if (req.where == null || req.where.isEmpty()) throw new BadRequestException("where conditions required for delete");
                return repo.delete(req.table, req.where);
            }
            case ALTER_ADD_COLUMN -> {
                sanitizer.validateColumnName(req.alterColumnName);
                sanitizer.validateAlterType(req.alterColumnType);
                return repo.alterAddColumn(req.table, req.alterColumnName, req.alterColumnType, req.alterNullable);
            }
            case ALTER_DROP_COLUMN -> {
                sanitizer.validateColumnName(req.alterColumnName);
                return repo.alterDropColumn(req.table, req.alterColumnName);
            }
            case ALTER_MODIFY_COLUMN -> {
                sanitizer.validateColumnName(req.alterColumnName);
                sanitizer.validateAlterType(req.alterColumnType);
                return repo.alterModifyColumn(req.table, req.alterColumnName, req.alterColumnType, req.alterNullable);
            }
            default -> throw new BadRequestException("unsupported operation");
        }
    }
}
```

---

## Repository (JdbcTemplate + NamedParameterJdbcTemplate)

```java
package com.example.dynamicdb.repository;

import com.example.dynamicdb.dto.ColumnInfo;
import com.example.dynamicdb.dto.OperationResult;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class DynamicDbRepository {

    private final JdbcTemplate jdbc;
    private final NamedParameterJdbcTemplate named;
    private final String identifierQuote; // from config

    public DynamicDbRepository(JdbcTemplate jdbc, NamedParameterJdbcTemplate named, org.springframework.core.env.Environment env) {
        this.jdbc = jdbc;
        this.named = named;
        this.identifierQuote = env.getProperty("spring.sql.identifier-quote", "\"");
    }

    public List<String> listTables(String prefix) {
        String sql = "SELECT table_name FROM information_schema.tables WHERE table_schema = current_schema() AND table_name LIKE :prefix";
        Map<String,Object> param = Map.of("prefix", prefix + "%");
        return named.query(sql, param, (rs, i) -> rs.getString(1));
    }

    public List<ColumnInfo> getColumns(String table) {
        String sql = "SELECT column_name, data_type, is_nullable, character_maximum_length FROM information_schema.columns WHERE table_schema = current_schema() AND table_name = :table";
        List<ColumnInfo> cols = named.query(sql, Map.of("table", table), (ResultSet rs, int rowNum) -> {
            String name = rs.getString(1);
            String type = rs.getString(2);
            boolean nullable = "YES".equals(rs.getString(3));
            Integer size = rs.getObject(4) != null ? rs.getInt(4) : null;
            return new ColumnInfo(name, type, nullable, size);
        });
        return cols;
    }

    private String quote(String identifier) {
        return identifierQuote + identifier + identifierQuote;
    }

    public OperationResult insert(String table, Map<String,Object> values) {
        List<String> cols = new ArrayList<>(values.keySet());
        String colCsv = cols.stream().map(this::quote).collect(Collectors.joining(","));
        String paramCsv = cols.stream().map(c -> ":" + c).collect(Collectors.joining(","));
        String sql = "INSERT INTO " + quote(table) + " (" + colCsv + ") VALUES (" + paramCsv + ")";
        int updated = named.update(sql, values);
        return new OperationResult(true, "insert ok", updated);
    }

    public OperationResult update(String table, Map<String,Object> values, Map<String,Object> where) {
        List<String> setParts = values.keySet().stream().map(c -> quote(c) + " = :" + c).collect(Collectors.toList());
        List<String> whereParts = where.keySet().stream().map(c -> quote(c) + " = :w_" + c).collect(Collectors.toList());
        Map<String,Object> params = new HashMap<>();
        params.putAll(values);
        where.forEach((k,v) -> params.put("w_" + k, v));
        String sql = "UPDATE " + quote(table) + " SET " + String.join(",", setParts) + " WHERE " + String.join(" AND ", whereParts);
        int updated = named.update(sql, params);
        return new OperationResult(true, "update ok", updated);
    }

    public OperationResult delete(String table, Map<String,Object> where) {
        List<String> whereParts = where.keySet().stream().map(c -> quote(c) + " = :" + c).collect(Collectors.toList());
        String sql = "DELETE FROM " + quote(table) + " WHERE " + String.join(" AND ", whereParts);
        int updated = named.update(sql, where);
        return new OperationResult(true, "delete ok", updated);
    }

    // ALTER: add/drop/modify column (very limited)
    public OperationResult alterAddColumn(String table, String column, String type, Boolean nullable) {
        String nullSql = (nullable == null || nullable) ? "" : " NOT NULL";
        String sql = "ALTER TABLE " + quote(table) + " ADD COLUMN " + quote(column) + " " + type + nullSql;
        jdbc.execute(sql);
        return new OperationResult(true, "alter add column executed", 0);
    }

    public OperationResult alterDropColumn(String table, String column) {
        String sql = "ALTER TABLE " + quote(table) + " DROP COLUMN " + quote(column);
        jdbc.execute(sql);
        return new OperationResult(true, "alter drop column executed", 0);
    }

    public OperationResult alterModifyColumn(String table, String column, String type, Boolean nullable) {
        // Implementation varies by DB - using PostgreSQL syntax here
        String nullSql = (nullable == null || nullable) ? "" : " SET NOT NULL";
        String sql = "ALTER TABLE " + quote(table) + " ALTER COLUMN " + quote(column) + " TYPE " + type;
        jdbc.execute(sql);
        if (nullable != null && !nullable) {
            jdbc.execute("ALTER TABLE " + quote(table) + " ALTER COLUMN " + quote(column) + " SET NOT NULL");
        } else if (nullable != null && nullable) {
            jdbc.execute("ALTER TABLE " + quote(table) + " ALTER COLUMN " + quote(column) + " DROP NOT NULL");
        }
        return new OperationResult(true, "alter modify column executed", 0);
    }
}
```

---

## SqlSanitizer (identifier and type validation)

```java
package com.example.dynamicdb.util;

import com.example.dynamicdb.exception.BadRequestException;
import org.springframework.stereotype.Component;

import java.util.Set;
import java.util.regex.Pattern;

@Component
public class SqlSanitizer {

    private static final Pattern IDENTIFIER = Pattern.compile("^[A-Za-z][A-Za-z0-9_]{0,126}$");
    private static final Set<String> ALLOWED_SIMPLE_TYPES = Set.of("INT","INTEGER","BIGINT","SMALLINT","TEXT","DATE","TIMESTAMP","BOOLEAN","BOOLEAN");

    public void validateAllowedTable(String table) {
        if (table == null || !table.startsWith("Trade_")) throw new BadRequestException("table must start with Trade_");
        validateIdentifier(table);
    }

    public void validateColumnName(String col) {
        validateIdentifier(col);
    }

    public void validateAlterType(String type) {
        if (type == null || type.isBlank()) throw new BadRequestException("alter type required");
        String t = type.strip().toUpperCase();
        // allow simple types and VARCHAR(n) and DECIMAL(p,s)
        if (ALLOWED_SIMPLE_TYPES.contains(t)) return;
        if (t.matches("VARCHAR\(\\d{1,5}\)") || t.matches("CHAR\(\\d{1,5}\)")) return;
        if (t.matches("DECIMAL\(\\d{1,3},\\d{1,3}\)")) return;
        // timestamp with zone etc could be allowed with additional rules
        throw new BadRequestException("unsupported alter column type: " + type);
    }

    private void validateIdentifier(String id) {
        if (id == null || id.isBlank()) throw new BadRequestException("identifier required");
        if (!IDENTIFIER.matcher(id).matches()) throw new BadRequestException("invalid identifier: " + id);
    }
}
```

---

## Exceptions and Handler

```java
package com.example.dynamicdb.exception;

public class BadRequestException extends RuntimeException {
    public BadRequestException(String msg) { super(msg); }
}

package com.example.dynamicdb.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<Object> handleBadRequest(BadRequestException ex) {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(Map.of("error", ex.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleAll(Exception ex) {
        ex.printStackTrace();
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of("error", "internal"));
    }
}
```

---

## Usage examples (curl)

1. List tables

```bash
curl -s "http://localhost:8080/api/dynamic/tables?prefix=Trade_"
```

2. Get columns

```bash
curl -s "http://localhost:8080/api/dynamic/tables/Trade_orders/columns"
```

3. Insert

```bash
curl -X POST http://localhost:8080/api/dynamic/execute -H 'Content-Type: application/json' -d '{
  "table":"Trade_orders",
  "operation":"INSERT",
  "values":{"order_id":12345, "amount": 1000, "customer":"Alice"}
}'
```

4. Update

```bash
curl -X POST http://localhost:8080/api/dynamic/execute -H 'Content-Type: application/json' -d '{
  "table":"Trade_orders",
  "operation":"UPDATE",
  "values":{"amount":2000},
  "where":{"order_id":12345}
}'
```

5. Delete

```bash
curl -X POST http://localhost:8080/api/dynamic/execute -H 'Content-Type: application/json' -d '{
  "table":"Trade_orders",
  "operation":"DELETE",
  "where":{"order_id":12345}
}'
```

6. Add column

```bash
curl -X POST http://localhost:8080/api/dynamic/execute -H 'Content-Type: application/json' -d '{
  "table":"Trade_orders",
  "operation":"ALTER_ADD_COLUMN",
  "alterColumnName":"new_flag",
  "alterColumnType":"BOOLEAN",
  "alterNullable":true
}'
```

---

## Important production recommendations

- **Authentication & Authorization**: restrict these endpoints to admin roles only. Enforce RBAC with Spring Security.
- **Audit logging**: record who ran what SQL and when. Keep immutable audit trail.
- **Backups & Dry-run**: for ALTER, run in a transactional migration subsystem and provide dry-run option.
- **Rate limiting & CSRF**: prevent mass deletes from accidental UI actions.
- **Stricter type mapping**: consider using database metadata to coerce/validate inputs to correct SQL types.
- **Use migrations**: prefer managed migrations (Flyway/Liquibase) for schema changes in CI/CD.

---

If you'd like, I can:
- produce a full downloadable ZIP project structure, or
- adapt this to MySQL-specific syntax (identifier quote `` ` ``), or
- add Spring Security config with an `ADMIN` role and sample in-memory users, or
- generate unit & integration tests and sample front-end request snippets for your UI.

Tell me which direction you'd like — I already prepared code for PostgreSQL-style metadata queries; if your DB is different, I will adapt it.


Done — I created a complete Spring Boot 3 utility (code + README + examples) in the canvas titled SpringBoot-DynamicDB-Utility. It includes controller, service, repository, DTOs, sanitization, exception handling, and usage curl examples targeted at PostgreSQL (notes for MySQL included).

Would you like me to:

adapt the SQL/identifier quoting for MySQL (backticks) instead of Postgres,

add Spring Security with an ADMIN role and example users, or

produce a downloadable ZIP with a full Maven/Gradle project and unit tests?


Pick one and I’ll extend the canvas accordingly.