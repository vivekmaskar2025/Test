package com.indusind.trade.api.gateway.filters;

import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.core.io.buffer.DefaultDataBufferFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpRequestDecorator;
import org.springframework.stereotype.Component;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.server.ServerWebExchange;

import com.indusind.trade.api.gateway.exception.DecryptionException;
import com.indusind.trade.api.gateway.utils.AESEncryptionService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Component
@Slf4j
@RequiredArgsConstructor
public class RequestDecryptionFilter extends AbstractGatewayFilterFactory<RequestDecryptionFilter.Config> {

    private final AESEncryptionService encryptionService;
    
    private static final int MAX_BODY_SIZE = 5 * 1024 * 1024; // 5 MB limit
    private static final int MAX_HEADER_SIZE = 8 * 1024; // 8 KB per header
    private static final int MAX_QUERY_PARAM_SIZE = 2 * 1024; // 2 KB per query param

    

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            String path = request.getPath().toString();
            HttpMethod method = request.getMethod();

            // Skip decryption for specific paths and binary content
            if (shouldSkipDecryption(path, method, request.getHeaders())) {
                log.debug("Skipping decryption for path: {} and method: {}", path, method);
                return chain.filter(exchange);
            }

            log.debug("Processing request decryption for path: {}", path);

            try {
                // Step 1: Decrypt headers with validation
                HttpHeaders decryptedHeaders = decryptHeaders(request.getHeaders());

                // Step 2: Decrypt and decode query parameters with validation
                MultiValueMap<String, String> decryptedQueryParams = decryptQueryParams(request.getQueryParams());

                // Step 3: Build new URI with decrypted query params
                URI newUri = buildNewUri(request, decryptedQueryParams);

                // Step 4: Decrypt body
                return decryptBody(exchange, request, decryptedHeaders, newUri, chain);

            } catch (DecryptionException e) {
                log.error("Decryption failed: {}", e.getMessage());
                return sendErrorResponse(exchange, HttpStatus.BAD_REQUEST, "Decryption failed: " + e.getMessage());
            } catch (IllegalArgumentException e) {
                log.error("Invalid request format: {}", e.getMessage());
                return sendErrorResponse(exchange, HttpStatus.BAD_REQUEST, "Invalid request format: " + e.getMessage());
            } catch (URISyntaxException e) {
                log.error("Invalid URI format: {}", e.getMessage());
                return sendErrorResponse(exchange, HttpStatus.BAD_REQUEST, "Invalid URI format");
            } catch (Exception e) {
                log.error("Unexpected error in decryption filter: {}", e.getMessage(), e);
                return sendErrorResponse(exchange, HttpStatus.INTERNAL_SERVER_ERROR, "Request processing failed");
            }
        };
    }

    /**
     * Decrypt request body with size validation
     */
    private Mono<Void> decryptBody(ServerWebExchange exchange, ServerHttpRequest request,
                                     HttpHeaders decryptedHeaders, URI newUri, 
                                     GatewayFilterChain chain) {
        
        return DataBufferUtils.join(request.getBody())
            .defaultIfEmpty(new DefaultDataBufferFactory().wrap(new byte[0]))
            .flatMap(dataBuffer -> {
                try {
                    // Validate body size
                    if (dataBuffer.readableByteCount() > MAX_BODY_SIZE) {
                        log.error("Request body exceeds max size limit: {} bytes", dataBuffer.readableByteCount());
                        DataBufferUtils.release(dataBuffer);
                        return sendErrorResponse(exchange, HttpStatus.PAYLOAD_TOO_LARGE, 
                            "Request body exceeds maximum allowed size of " + (MAX_BODY_SIZE / 1024 / 1024) + " MB");
                    }

                    // Handle empty body
                    if (dataBuffer.readableByteCount() == 0) {
                        log.debug("Empty request body, skipping decryption");
                        DataBufferUtils.release(dataBuffer);
                        
                        ServerHttpRequest mutatedRequest = createMutatedRequest(request, decryptedHeaders, 
                            newUri, Flux.empty(), 0);
                        return chain.filter(exchange.mutate().request(mutatedRequest).build());
                    }

                    // Read body content
                    byte[] bytes = new byte[dataBuffer.readableByteCount()];
                    dataBuffer.read(bytes);
                    DataBufferUtils.release(dataBuffer);

                    String encryptedBody = new String(bytes, StandardCharsets.UTF_8);
                    
                    // Validate Base64 encoding
                    if (!encryptionService.isValidBase64(encryptedBody)) {
                        log.error("Invalid Base64 encoded body");
                        return sendErrorResponse(exchange, HttpStatus.BAD_REQUEST, 
                            "Invalid encrypted data format");
                    }

                    // Decrypt the body
                    String decryptedBody;
                    try {
                        decryptedBody = encryptionService.decrypt(encryptedBody);
                        log.debug("Request body decrypted successfully, size: {} bytes", decryptedBody.length());
                    } catch (RuntimeException e) {
                        log.error("Body decryption failed: {}", e.getMessage());
                        return sendErrorResponse(exchange, HttpStatus.BAD_REQUEST, 
                            "Failed to decrypt request body");
                    }

                    // Validate decrypted content is valid JSON/XML if needed
                    if (!isValidContent(decryptedBody, decryptedHeaders.getContentType())) {
                        log.error("Decrypted body contains invalid content");
                        return sendErrorResponse(exchange, HttpStatus.BAD_REQUEST, 
                            "Invalid request content after decryption");
                    }

                    byte[] decryptedBytes = decryptedBody.getBytes(StandardCharsets.UTF_8);
                    DataBuffer buffer = new DefaultDataBufferFactory().wrap(decryptedBytes);

                    // Create mutated request with decrypted body
                    ServerHttpRequest mutatedRequest = createMutatedRequest(request, decryptedHeaders, 
                        newUri, Flux.just(buffer), decryptedBytes.length);

                    return chain.filter(exchange.mutate().request(mutatedRequest).build());

                } catch (Exception e) {
                    log.error("Error processing request body: {}", e.getMessage(), e);
                    return sendErrorResponse(exchange, HttpStatus.INTERNAL_SERVER_ERROR, 
                        "Failed to process request");
                }
            })
            .onErrorResume(e -> {
                log.error("Error in body decryption: {}", e.getMessage(), e);
                
                HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
                String message = "Request processing failed";

                if (e instanceof IllegalStateException && e.getMessage().contains("Payload too large")) {
                    status = HttpStatus.PAYLOAD_TOO_LARGE;
                    message = "Request body exceeds allowed size";
                } else if (e instanceof URISyntaxException) {
                    status = HttpStatus.BAD_REQUEST;
                    message = "Invalid URI format";
                } else if (e instanceof IllegalArgumentException) {
                    status = HttpStatus.BAD_REQUEST;
                    message = "Invalid request format";
                } else if (e instanceof DecryptionException) {
                    status = HttpStatus.BAD_REQUEST;
                    message = "Decryption failed";
                }

                return sendErrorResponse(exchange, status, message);
            });
    }

    /**
     * Create mutated request with decrypted data
     */
    private ServerHttpRequest createMutatedRequest(ServerHttpRequest originalRequest,
                                                     HttpHeaders decryptedHeaders,
                                                     URI newUri,
                                                     Flux<DataBuffer> body,
                                                     long contentLength) {
        return new ServerHttpRequestDecorator(originalRequest) {
            @Override
            public URI getURI() {
                return newUri;
            }

            @Override
            public Flux<DataBuffer> getBody() {
                return body;
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.putAll(decryptedHeaders);
                
                if (contentLength > 0) {
                    headers.setContentLength(contentLength);
                }
                
                // Preserve or set content type
                MediaType originalContentType = originalRequest.getHeaders().getContentType();
                if (originalContentType != null) {
                    headers.setContentType(originalContentType);
                } else if (contentLength > 0) {
                    headers.setContentType(MediaType.APPLICATION_JSON);
                }
                
                return headers;
            }
        };
    }

    /**
     * Decrypt headers with validation
     */
    private HttpHeaders decryptHeaders(HttpHeaders originalHeaders) {
        HttpHeaders decryptedHeaders = new HttpHeaders();
        
        originalHeaders.forEach((key, values) -> {
            try {
                List<String> decryptedValues = values.stream()
                    .map(this::safeHeaderDecrypt)
                    .collect(Collectors.toList());
                
                // Validate header size after decryption
                for (String value : decryptedValues) {
                    if (value != null && value.length() > MAX_HEADER_SIZE) {
                        log.warn("Header {} exceeds max size after decryption, truncating", key);
                        throw new IllegalArgumentException("Header value too large: " + key);
                    }
                }
                
                decryptedHeaders.put(key, decryptedValues);
            } catch (Exception e) {
                log.error("Failed to decrypt header {}: {}", key, e.getMessage());
                // Keep original value if decryption fails for non-critical headers
                if (isCriticalHeader(key)) {
                    throw new DecryptionException("Failed to decrypt critical header: " + key, e);
                }
                decryptedHeaders.put(key, values);
            }
        });
        
        return decryptedHeaders;
    }

    /**
     * Decrypt query parameters with validation
     */
    private MultiValueMap<String, String> decryptQueryParams(MultiValueMap<String, String> originalParams) {
        MultiValueMap<String, String> decryptedQueryParams = new LinkedMultiValueMap<>();
        
        originalParams.forEach((key, values) -> {
            try {
                List<String> decryptedValues = values.stream()
                    .map(this::safeDecrypt)
                    .map(this::urlDecode)
                    .collect(Collectors.toList());
                
                // Validate query param size after decryption
                for (String value : decryptedValues) {
                    if (value != null && value.length() > MAX_QUERY_PARAM_SIZE) {
                        log.warn("Query param {} exceeds max size after decryption", key);
                        throw new IllegalArgumentException("Query parameter value too large: " + key);
                    }
                }
                
                decryptedQueryParams.put(key, decryptedValues);
            } catch (Exception e) {
                log.error("Failed to decrypt query param {}: {}", key, e.getMessage());
                throw new DecryptionException("Failed to decrypt query parameter: " + key, e);
            }
        });
        
        return decryptedQueryParams;
    }

    /**
     * Build new URI with decrypted query parameters
     */
    private URI buildNewUri(ServerHttpRequest originalRequest, 
                            MultiValueMap<String, String> queryParams) throws URISyntaxException {
        
        if (queryParams.isEmpty()) {
            return originalRequest.getURI();
        }
        
        StringBuilder newQuery = new StringBuilder();
        queryParams.forEach((key, values) -> {
            for (String value : values) {
                if (newQuery.length() > 0) {
                    newQuery.append("&");
                }
                newQuery.append(key).append("=").append(value);
            }
        });

        try {
            URI originalUri = originalRequest.getURI();
            return new URI(
                originalUri.getScheme(),
                originalUri.getAuthority(),
                originalUri.getPath(),
                newQuery.length() > 0 ? newQuery.toString() : null,
                originalUri.getFragment()
            );
        } catch (URISyntaxException e) {
            log.error("Failed to build URI: {}", e.getMessage());
            throw e;
        }
    }

    /**
     * Safely decrypt header value, return original if decryption fails
     */
    private String safeHeaderDecrypt(String value) {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        try {
            // Check if value looks like encrypted data (Base64)
            if (encryptionService.isValidBase64(value)) {
                return encryptionService.decrypt(value);
            }
            return value;
        } catch (Exception e) {
            log.debug("Header decryption failed, using original value: {}", e.getMessage());
            return value;
        }
    }

    /**
     * Safely decrypt value with error handling
     */
    private String safeDecrypt(String value) {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        try {
            return encryptionService.decrypt(value);
        } catch (Exception e) {
            log.error("Decryption failed for value: {}", e.getMessage());
            throw new DecryptionException("Decryption failed", e);
        }
    }

    /**
     * URL decode with error handling
     */
    private String urlDecode(String value) {
        if (value == null || value.isEmpty()) {
            return value;
        }
        
        try {
            return URLDecoder.decode(value, StandardCharsets.UTF_8);
        } catch (Exception e) {
            log.error("URL decoding failed: {}", e.getMessage());
            return value;
        }
    }

    /**
     * Validate if content is valid based on content type
     */
    private boolean isValidContent(String content, MediaType contentType) {
        if (content == null || content.isEmpty()) {
            return true;
        }
        
        try {
            if (contentType != null) {
                if (MediaType.APPLICATION_JSON.includes(contentType)) {
                    // Basic JSON validation
                    content = content.trim();
                    return (content.startsWith("{") && content.endsWith("}")) ||
                           (content.startsWith("[") && content.endsWith("]"));
                } else if (MediaType.APPLICATION_XML.includes(contentType)) {
                    // Basic XML validation
                    content = content.trim();
                    return content.startsWith("<") && content.endsWith(">");
                }
            }
            return true; // Allow other content types
        } catch (Exception e) {
            log.error("Content validation failed: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Check if decryption should be skipped
     */
    private boolean shouldSkipDecryption(String path, HttpMethod method, HttpHeaders headers) {
        // Skip for specific paths (customize as needed)
        if (path.contains("/getTokens") || 
            path.contains("/refreshToken") ||
            path.contains("/health") ||
            path.contains("/actuator")) {
            return true;
        }
        
        // Skip for binary content
        if (isBinaryContent(headers)) {
            return true;
        }
        
        // Skip for GET and DELETE requests (usually no body)
        if (HttpMethod.GET.equals(method) || HttpMethod.DELETE.equals(method)) {
            return true;
        }
        
        return false;
    }

    /**
     * Check if content is binary
     */
    private boolean isBinaryContent(HttpHeaders headers) {
        MediaType contentType = headers.getContentType();
        
        if (contentType == null) {
            return false;
        }
        
        return MediaType.MULTIPART_FORM_DATA.includes(contentType) ||
               MediaType.APPLICATION_OCTET_STREAM.includes(contentType) ||
               contentType.toString().contains("image/") ||
               contentType.toString().contains("video/") ||
               contentType.toString().contains("audio/") ||
               contentType.toString().contains("application/pdf");
    }

    /**
     * Check if header is critical and must be decrypted
     */
    private boolean isCriticalHeader(String headerName) {
        return "Authorization".equalsIgnoreCase(headerName) ||
               "X-API-Key".equalsIgnoreCase(headerName) ||
               "X-Auth-Token".equalsIgnoreCase(headerName);
    }

    /**
     * Send error response
     */
    private Mono<Void> sendErrorResponse(ServerWebExchange exchange, HttpStatus status, String message) {
        exchange.getResponse().setStatusCode(status);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        
        String errorJson = String.format(
            "{\"status\":\"error\",\"code\":%d,\"message\":\"%s\",\"timestamp\":\"%s\"}",
            status.value(),
            message.replace("\"", "\\\""),
            java.time.Instant.now().toString()
        );
        
        DataBuffer buffer = new DefaultDataBufferFactory()
            .wrap(errorJson.getBytes(StandardCharsets.UTF_8));
        
        return exchange.getResponse().writeWith(Mono.just(buffer))
            .doOnError(error -> log.error("Error writing response: {}", error.getMessage()));
    }

    public static class Config {
        // Configuration properties if needed
        private boolean strictMode = false;
        private int maxBodySize = MAX_BODY_SIZE;
        
        public boolean isStrictMode() {
            return strictMode;
        }
        
        public void setStrictMode(boolean strictMode) {
            this.strictMode = strictMode;
        }
        
        public int getMaxBodySize() {
            return maxBodySize;
        }
        
        public void setMaxBodySize(int maxBodySize) {
            this.maxBodySize = maxBodySize;
        }
    }
}
package com.indusind.trade.api.gateway.filters;

import java.nio.charset.StandardCharsets;
import java.time.Duration;

import org.reactivestreams.Publisher;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferFactory;
import org.springframework.core.io.buffer.DataBufferUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.http.server.reactive.ServerHttpResponseDecorator;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import com.indusind.trade.api.gateway.utils.AESEncryptionService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.annotation.NonNull;

/**
 * Production-ready response encryption filter.
 *
 * - Joins the response body safely (with max size guard) - Skips encryption for
 * non-2xx responses, empty bodies, or non-textual content-types - Preserves
 * headers and updates Content-Length when encrypted - Adds X-Response-Encrypted
 * and X-Encryption-Status headers for observability - Falls back to original
 * response when encryption fails
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class ResponseEncryptionFilter extends AbstractGatewayFilterFactory<ResponseEncryptionFilter.Config> {

	private final AESEncryptionService encryptionService;

	// Maximum bytes to join into memory before refusing encryption (protects from
	// OOM).
	// Tune this based on your environment (e.g., 2MB = 2 * 1024 * 1024).
	private static final int DEFAULT_MAX_BODY_BYTES = 2 * 1024 * 1024;

	// Timeout for encryption operation (defensive).
	private static final Duration ENCRYPTION_TIMEOUT = Duration.ofSeconds(5);

	@Override
	public GatewayFilter apply(Config config) {
		final int maxBodyBytes = config.getMaxBodyBytes() > 0 ? config.getMaxBodyBytes() : DEFAULT_MAX_BODY_BYTES;

		return (exchange, chain) -> {
			ServerHttpResponse originalResponse = exchange.getResponse();
			DataBufferFactory bufferFactory = originalResponse.bufferFactory();

			ServerHttpResponseDecorator decorated = new ServerHttpResponseDecorator(originalResponse) {

				@Override
				@SuppressWarnings("unchecked")
				public Mono<Void> writeWith(@NonNull Publisher<? extends DataBuffer> body) {
					// If not a Flux, let it pass through
					if (!(body instanceof Flux)) {
						return super.writeWith(body);
					}

					Flux<? extends DataBuffer> fluxBody = (Flux<? extends DataBuffer>) body;

					// Join and process
					return DataBufferUtils.join(fluxBody).flatMap(joined -> {
						try {
							int readable = joined.readableByteCount();
							if (readable == 0) {
								// empty body - pass through
								DataBufferUtils.release(joined);
								log.debug("[ResponseEncryptionFilter] Empty response body - skipping encryption");
								// ensure headers reflect empty body
								getDelegate().getHeaders().remove(HttpHeaders.CONTENT_LENGTH);
								return super.writeWith(Mono.empty());
							}

							if (readable > maxBodyBytes) {
								// avoid huge aggregation
								log.warn(
										"[ResponseEncryptionFilter] Response body size {} bytes exceeds max {} - skipping encryption",
										readable, maxBodyBytes);
								byte[] originalBytes = new byte[readable];
								joined.read(originalBytes);
								DataBufferUtils.release(joined);
								// write original
								getDelegate().getHeaders().remove(HttpHeaders.CONTENT_LENGTH);
								return super.writeWith(Mono.just(bufferFactory.wrap(originalBytes)));
							}

							// Check status
							HttpStatusCode statusCode = getStatusCode();
							if (statusCode == null || !statusCode.is2xxSuccessful()) {
								// error or non-2xx: do not encrypt
								log.debug("[ResponseEncryptionFilter] Skipping encryption for status: {}", statusCode);
								byte[] originalBytes = new byte[readable];
								joined.read(originalBytes);
								DataBufferUtils.release(joined);
								// write original buffer (update headers)
								getDelegate().getHeaders().remove(HttpHeaders.CONTENT_LENGTH);
								return super.writeWith(Mono.just(bufferFactory.wrap(originalBytes)));
							}

							// Check content-type
							MediaType contentType = getDelegate().getHeaders().getContentType();
							if (!isTextLike(contentType)) {
								// Binary or unknown: skip encryption (avoid corrupting binary)
								log.debug(
										"[ResponseEncryptionFilter] Skipping encryption for non-text content-type: {}",
										contentType);
								byte[] originalBytes = new byte[readable];
								joined.read(originalBytes);
								DataBufferUtils.release(joined);
								getDelegate().getHeaders().remove(HttpHeaders.CONTENT_LENGTH);
								return super.writeWith(Mono.just(bufferFactory.wrap(originalBytes)));
							}

							byte[] originalBytes = new byte[readable];
							joined.read(originalBytes);
							DataBufferUtils.release(joined);
							String originalBody = new String(originalBytes, StandardCharsets.UTF_8);

							if (!StringUtils.hasText(originalBody)) {
								log.debug("[ResponseEncryptionFilter] Blank response body - skipping encryption");
								getDelegate().getHeaders().remove(HttpHeaders.CONTENT_LENGTH);
								return super.writeWith(Mono.just(bufferFactory.wrap(originalBytes)));
							}

							// Skip encryption for error-like JSON (simple heuristic)
							if (originalBody.contains("\"error\"") || originalBody.contains("\"status\":\"error\"")) {
								log.debug("[ResponseEncryptionFilter] Detected error-like body - skipping encryption");
								getDelegate().getHeaders().remove(HttpHeaders.CONTENT_LENGTH);
								return super.writeWith(Mono.just(bufferFactory.wrap(originalBytes)));
							}

							// Try to encrypt (bounded by timeout)
							return Mono.fromCallable(() -> encryptionService.encrypt(originalBody))
									.timeout(ENCRYPTION_TIMEOUT).map(encrypted -> {
										byte[] encryptedBytes = encrypted.getBytes(StandardCharsets.UTF_8);

										// Update headers: content-type remains same (text/json), but length changes
										HttpHeaders headers = getDelegate().getHeaders();
										if (headers != null) {
											headers.setContentLength(encryptedBytes.length);
											// You may want to keep content-type same (JSON-> still JSON-ish encrypted
											// string)
											// or set a specific content-type for encrypted payloads. We'll preserve it.
											headers.set("X-Response-Encrypted", "true");
											headers.set("X-Encryption-Status", "success");
										}

										return bufferFactory.wrap(encryptedBytes);
									}).onErrorResume(throwable -> {
										// Encryption failed â€” fallback to original and mark header
										log.error(
												"[ResponseEncryptionFilter] Encryption failed - returning original body",
												throwable);
										HttpHeaders headers = getDelegate().getHeaders();
										if (headers != null) {
											headers.remove(HttpHeaders.CONTENT_LENGTH); // let Netty/chunking handle it
											headers.set("X-Response-Encrypted", "false");
											headers.set("X-Encryption-Status", "failed");
											headers.set("X-Encryption-Error", throwable.getClass().getSimpleName());
										}
										return Mono.just(bufferFactory.wrap(originalBytes));
									}).flatMapMany(buf -> Flux.just(buf)).as(super::writeWith);

						} catch (Throwable t) {
							DataBufferUtils.release(joined);
							log.error("[ResponseEncryptionFilter] Unexpected error while encrypting response", t);
							return Mono.error(t);
						}
					});
				}

				@Override
				public Mono<Void> writeAndFlushWith(Publisher<? extends Publisher<? extends DataBuffer>> body) {
					// Delegate to writeWith by flattening publishers to a single Flux
					return writeWith(Flux.from(body).flatMapSequential(p -> Flux.from(p)));
				}
			};

			// continue chain with decorated response
			return chain.filter(exchange.mutate().response(decorated).build());
		};
	}

	private boolean isTextLike(MediaType contentType) {
		if (contentType == null)
			return true; // be permissive if unknown
		if (MediaType.APPLICATION_JSON.includes(contentType))
			return true;
		if (MediaType.TEXT_PLAIN.includes(contentType))
			return true;
		if (MediaType.APPLICATION_XML.includes(contentType))
			return true;
		if (contentType.getType() != null && contentType.getType().equalsIgnoreCase("text"))
			return true;
		// Add other textual types if required
		return false;
	}

	public static class Config {
		// max body bytes to aggregate; default used when 0 or negative
		private int maxBodyBytes = DEFAULT_MAX_BODY_BYTES;

		public int getMaxBodyBytes() {
			return maxBodyBytes;
		}

		public void setMaxBodyBytes(int maxBodyBytes) {
			this.maxBodyBytes = maxBodyBytes;
		}
	}
}
package com.indusind.trade.api.gateway.filters;

import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientRequestException;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import org.springframework.web.server.ServerWebExchange;

import com.indusind.trade.api.gateway.config.PublicEndpointsConfig;
import com.indusind.trade.api.gateway.exception.UnauthorizedException;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

/**
 * Enhanced JWT Authentication Filter with comprehensive error handling and
 * production-ready features
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends AbstractGatewayFilterFactory<JwtAuthenticationFilter.Config> {

	private final WebClient.Builder webClientBuilder;
	private final PublicEndpointsConfig publicEndpointsConfig;

	@Value("${jwt.auth-service-url}")
	private String authServiceUrl;

	@Value("${jwt.validation-endpoint}")
	private String validationEndpoint;

	private final AntPathMatcher pathMatcher = new AntPathMatcher();

	// Cache for token validation results (optional - implement with Redis in
	// production)
	// private final Map<String, ValidationResult> tokenCache = new
	// ConcurrentHashMap<>();

	private static final String BEARER_PREFIX = "Bearer ";
	private static final int MAX_TOKEN_LENGTH = 2048; // JWT tokens shouldn't exceed this
	private static final int MIN_TOKEN_LENGTH = 20; // Minimum reasonable JWT length

	@Override
	public GatewayFilter apply(Config config) {
		return (exchange, chain) -> {
			String path = exchange.getRequest().getPath().toString();
			String method = exchange.getRequest().getMethod().toString();

			log.debug("Processing JWT authentication for path: {} [{}]", path, method);

			// Step 1: Check if endpoint is public
			if (isPublicEndpoint(path)) {
				log.debug("Public endpoint detected: {}. Skipping JWT validation.", path);
				return chain.filter(exchange);
			}

			// Step 2: Extract and validate Authorization header
			String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

			if (authHeader == null || authHeader.isEmpty()) {
				log.error("Missing Authorization header for path: {}", path);
				return sendErrorResponse(exchange, HttpStatus.UNAUTHORIZED, "Missing Authorization header",
						"MISSING_AUTH_HEADER");
			}

			if (!authHeader.startsWith(BEARER_PREFIX)) {
				log.error("Invalid Authorization header format for path: {}. Header: {}", path, maskToken(authHeader));
				return sendErrorResponse(exchange, HttpStatus.UNAUTHORIZED,
						"Invalid Authorization header format. Expected: Bearer <token>", "INVALID_AUTH_HEADER_FORMAT");
			}

			// Step 3: Extract and validate JWT token
			String token = authHeader.substring(BEARER_PREFIX.length()).trim();

			if (!isValidTokenFormat(token)) {
				log.error("Invalid JWT token format for path: {}", path);
				return sendErrorResponse(exchange, HttpStatus.UNAUTHORIZED, "Invalid JWT token format",
						"INVALID_TOKEN_FORMAT");
			}

			log.debug("Validating JWT token for path: {} (token length: {})", path, token.length());

			// Step 4: Validate token with Auth Service
			return validateToken(token, path, exchange).flatMap(validationResponse -> {
				log.debug("Token validation succeeded for path: {}. User: {}, Role: {}", path,
						validationResponse.getUsername(), validationResponse.getRole());

				// Step 5: Add user context to request headers
				ServerHttpRequest modifiedRequest = exchange.getRequest().mutate()
						.header("X-User-Role", validationResponse.getRole())
						.header("X-User-Id", validationResponse.getUserId())
						.header("X-Auth-Time", String.valueOf(System.currentTimeMillis())).build();

				return chain.filter(exchange.mutate().request(modifiedRequest).build());
			}).onErrorResume(e -> handleValidationError(e, exchange, path));
		};
	}

	/**
	 * Validate token with Auth Service
	 */
	private Mono<TokenValidationResponse> validateToken(String token, String path, ServerWebExchange exchange) {
		WebClient webClient = webClientBuilder.baseUrl(authServiceUrl).build();

		return webClient.post().uri(validationEndpoint).header(HttpHeaders.AUTHORIZATION, BEARER_PREFIX + token)
				.header("X-Request-Path", path).header("X-Request-Id", exchange.getRequest().getId()).retrieve()
				.onStatus(status -> status.equals(HttpStatus.UNAUTHORIZED), response -> response
						.bodyToMono(String.class)
						.flatMap(body -> Mono
								.<Throwable>error(new UnauthorizedException("Token validation failed: " + body)))
						.switchIfEmpty(
								Mono.defer(() -> Mono.error(new UnauthorizedException("Token is invalid or expired")))))
				.onStatus(HttpStatusCode::is4xxClientError,
						response -> response.bodyToMono(String.class)
								.flatMap(body -> Mono.<Throwable>error(new RuntimeException("Client error: " + body)))
								.switchIfEmpty(Mono.error(new RuntimeException("Client error from auth service"))))
				.onStatus(HttpStatusCode::is5xxServerError,
						response -> response.bodyToMono(String.class).flatMap(
								body -> Mono.<Throwable>error(new RuntimeException("Auth service error: " + body)))
								.switchIfEmpty(Mono.error(new RuntimeException("Auth service internal error"))))
				.bodyToMono(TokenValidationResponse.class).doOnError(WebClientResponseException.class, e -> {
					log.error("Auth service call failed for path: {}. Status: {}, Body: {}", path, e.getStatusCode(),
							e.getResponseBodyAsString());
				}).doOnError(WebClientRequestException.class, e -> {
					log.error("Auth service connection failed for path: {}. Error: {}", path, e.getMessage());
				});
	}

	/**
	 * Handle validation errors with specific error responses
	 */
	private Mono<Void> handleValidationError(Throwable error, ServerWebExchange exchange, String path) {
		log.error("Token validation error for path: {}. Error type: {}, Message: {}", path,
				error.getClass().getSimpleName(), error.getMessage());

		// Unauthorized - Invalid or expired token
		if (error instanceof UnauthorizedException) {
			return sendErrorResponse(exchange, HttpStatus.UNAUTHORIZED, error.getMessage(), "INVALID_TOKEN");
		}

		// WebClient 401 Unauthorized
		if (error instanceof WebClientResponseException.Unauthorized) {
			WebClientResponseException.Unauthorized ex = (WebClientResponseException.Unauthorized) error;
			return sendErrorResponse(exchange, HttpStatus.UNAUTHORIZED, "Invalid or expired token",
					"TOKEN_VALIDATION_FAILED", ex.getResponseBodyAsString());
		}

		// WebClient 403 Forbidden
		if (error instanceof WebClientResponseException.Forbidden) {
			return sendErrorResponse(exchange, HttpStatus.FORBIDDEN, "Access denied", "ACCESS_DENIED");
		}

		// WebClient 503 Service Unavailable
		if (error instanceof WebClientResponseException.ServiceUnavailable) {
			return sendErrorResponse(exchange, HttpStatus.SERVICE_UNAVAILABLE,
					"Authentication service is temporarily unavailable", "AUTH_SERVICE_UNAVAILABLE");
		}

		// WebClient other 4xx errors
		if (error instanceof WebClientResponseException) {
			WebClientResponseException ex = (WebClientResponseException) error;
			HttpStatus status = HttpStatus.valueOf(ex.getStatusCode().value());

			if (status.is4xxClientError()) {
				return sendErrorResponse(exchange, status, "Authentication failed", "AUTH_CLIENT_ERROR",
						ex.getResponseBodyAsString());
			}

			if (status.is5xxServerError()) {
				return sendErrorResponse(exchange, HttpStatus.SERVICE_UNAVAILABLE, "Authentication service error",
						"AUTH_SERVICE_ERROR");
			}
		}

		// Connection errors
		if (error instanceof WebClientRequestException) {
			return sendErrorResponse(exchange, HttpStatus.SERVICE_UNAVAILABLE,
					"Cannot connect to authentication service", "AUTH_SERVICE_CONNECTION_ERROR");
		}

		// Timeout errors
		if (error instanceof TimeoutException) {
			return sendErrorResponse(exchange, HttpStatus.GATEWAY_TIMEOUT, "Authentication service timeout",
					"AUTH_SERVICE_TIMEOUT");
		}

		// Generic errors
		return sendErrorResponse(exchange, HttpStatus.INTERNAL_SERVER_ERROR, "Internal authentication error",
				"INTERNAL_AUTH_ERROR");
	}

	/**
	 * Check if endpoint is public (no authentication required)
	 */
	private boolean isPublicEndpoint(String path) {
		if (publicEndpointsConfig == null || publicEndpointsConfig.getPublicEndpoints() == null) {
			log.warn("Public endpoints configuration is not available");
			return false;
		}

		boolean isPublic = publicEndpointsConfig.getPublicEndpoints().stream().anyMatch(pattern -> {
			boolean matches = pathMatcher.match(pattern, path);
			if (matches) {
				log.debug("Path {} matches public pattern: {}", path, pattern);
			}
			return matches;
		});

		return isPublic;
	}

	/**
	 * Validate JWT token format
	 */
	private boolean isValidTokenFormat(String token) {
		if (token == null || token.isEmpty()) {
			return false;
		}

		// Check token length
		if (token.length() < MIN_TOKEN_LENGTH || token.length() > MAX_TOKEN_LENGTH) {
			log.error("Invalid token length: {}. Expected: {}-{}", token.length(), MIN_TOKEN_LENGTH, MAX_TOKEN_LENGTH);
			return false;
		}

		// Basic JWT structure check (header.payload.signature)
		String[] parts = token.split("\\.");
		if (parts.length != 3) {
			log.error("Invalid JWT structure. Expected 3 parts, found: {}", parts.length);
			return false;
		}

		// Check if parts are not empty
		for (String part : parts) {
			if (part == null || part.isEmpty()) {
				log.error("JWT contains empty part");
				return false;
			}
		}

		// Check for valid Base64 URL characters
		if (!token.matches("^[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+\\.[A-Za-z0-9_-]+$")) {
			log.error("JWT contains invalid characters");
			return false;
		}

		return true;
	}

	/**
	 * Mask token for logging (security)
	 */
	private String maskToken(String token) {
		if (token == null || token.length() < 10) {
			return "***";
		}
		return token.substring(0, 10) + "..." + token.substring(token.length() - 10);
	}

	/**
	 * Send error response with detailed information
	 */
	private Mono<Void> sendErrorResponse(ServerWebExchange exchange, HttpStatus status, String message,
			String errorCode) {
		return sendErrorResponse(exchange, status, message, errorCode, null);
	}

	/**
	 * Send error response with optional details
	 */
	private Mono<Void> sendErrorResponse(ServerWebExchange exchange, HttpStatus status, String message,
			String errorCode, String details) {
		exchange.getResponse().setStatusCode(status);
		exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);

		Map<String, Object> errorResponse = new HashMap<>();
		errorResponse.put("status", "error");
		errorResponse.put("code", status.value());
		errorResponse.put("error", status.getReasonPhrase());
		errorResponse.put("message", message);
		errorResponse.put("errorCode", errorCode);
		errorResponse.put("path", exchange.getRequest().getPath().toString());
		errorResponse.put("timestamp", java.time.Instant.now().toString());

		if (details != null && !details.isEmpty()) {
			errorResponse.put("details", details);
		}

		String responseBody = toJson(errorResponse);
		byte[] bytes = responseBody.getBytes(StandardCharsets.UTF_8);

		return exchange.getResponse().writeWith(Mono.just(exchange.getResponse().bufferFactory().wrap(bytes)))
				.doOnError(error -> log.error("Error writing response: {}", error.getMessage()));
	}

	/**
	 * Convert map to JSON string (simple implementation)
	 */
	private String toJson(Map<String, Object> map) {
		StringBuilder json = new StringBuilder("{");

		map.forEach((key, value) -> {
			if (json.length() > 1) {
				json.append(",");
			}
			json.append("\"").append(key).append("\":");

			if (value instanceof String) {
				json.append("\"").append(escapeJson((String) value)).append("\"");
			} else if (value instanceof Number) {
				json.append(value);
			} else {
				json.append("\"").append(value).append("\"");
			}
		});

		json.append("}");
		return json.toString();
	}

	/**
	 * Escape special characters in JSON strings
	 */
	private String escapeJson(String str) {
		return str.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n").replace("\r", "\\r").replace("\t",
				"\\t");
	}

	public static class Config {
		private boolean strictMode = true;
		private boolean cacheEnabled = false;
		private int cacheTTLSeconds = 300;

		public boolean isStrictMode() {
			return strictMode;
		}

		public void setStrictMode(boolean strictMode) {
			this.strictMode = strictMode;
		}

		public boolean isCacheEnabled() {
			return cacheEnabled;
		}

		public void setCacheEnabled(boolean cacheEnabled) {
			this.cacheEnabled = cacheEnabled;
		}

		public int getCacheTTLSeconds() {
			return cacheTTLSeconds;
		}

		public void setCacheTTLSeconds(int cacheTTLSeconds) {
			this.cacheTTLSeconds = cacheTTLSeconds;
		}
	}

	/**
	 * Token validation response DTO
	 */
	public static class TokenValidationResponse {
		private boolean valid;
		private String username;
		private String role;
		private String userId;
		private Long expiresAt;

		public TokenValidationResponse() {
		}

		public TokenValidationResponse(boolean valid, String username, String role, String userId) {
			this.valid = valid;
			this.username = username;
			this.role = role;
			this.userId = userId;
		}

		// Getters and setters
		public boolean isValid() {
			return valid;
		}

		public void setValid(boolean valid) {
			this.valid = valid;
		}

		public String getUsername() {
			return username;
		}

		public void setUsername(String username) {
			this.username = username;
		}

		public String getRole() {
			return role;
		}

		public void setRole(String role) {
			this.role = role;
		}

		public String getUserId() {
			return userId;
		}

		public void setUserId(String userId) {
			this.userId = userId;
		}

		public Long getExpiresAt() {
			return expiresAt;
		}

		public void setExpiresAt(Long expiresAt) {
			this.expiresAt = expiresAt;
		}
	}
}
